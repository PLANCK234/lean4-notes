# mathlib 贡献指南

本文将为您详细介绍如何向 Lean 社区的数学库 **mathlib** 做出贡献，包括代码风格要求、提交流程，以及社区对新定理/引理的接受标准。本指南参考了 LeanProver 社区官方文档、mathlib 贡献指南和其他权威资料，帮助您一步步了解从编写代码到 Pull Request 合并的整个过程。

主要内容：

1. 提交证明时对结构和风格的规范要求，尤其是 Lean 代码组织和命名规则；
2. 完整的提交流程，包括如何使用 GitHub 提交 pull request、参与 review 和合并过程；
3. 社区对新增定理或引理的接受标准，例如对通用性、命名、冗余等的评判标准。

## Lean 源代码风格与规范

mathlib 对 Lean 源代码有一套统一的风格约定，包括命名规则、代码格式、文件组织结构以及注释和文档要求。遵守这些规范可以提高代码可读性，方便社区审核和后续维护。

### Lean 代码书写风格

* **代码格式与缩进：** 所有声明（如 `def`、`lemma`、`theorem`、`instance` 等）以及命令（如 `namespace`、`section` 等）都应顶格书写，不因为置于命名空间内就缩进。定理证明部分相对声明头缩进2个空格。如果定理声明本身需要换行延续，续行缩进4个空格，而证明部分仍只缩进2个空格。例如：

  ```lean
  theorem nat_case {P : Nat → Prop} (n : Nat) (H1 : P 0) (H2 : ∀ m, P (succ m)) : P n :=
    Nat.recOn n H1 (fun m IH ↦ H2 m)
  ```

  上例中，`theorem` 声明从行首开始，证明体缩进2空格。若使用 `by` 引入战术证明，`by` 通常放在前一行行末而不是独占一行。此外，代码中建议在「:`、`:=\`、二元操作符」两侧添加空格，并尽量将它们放在行尾而非新行开头，以增强可读性。

* **行宽限制：** 建议每行代码不超过 100 个字符。过长的行会降低阅读体验，在 VS Code 中可以开启竖线指示 100 列的界限来辅助遵循该规范。

* **其余格式规范：** 不要将不必要的括号与其内容分离到不同行（避免「孤立括号」）。对于长的证明，可以考虑将证明拆分为多个辅助引理或使用更合适的战术以提高可读性。必要时也可对证明进行“压缩”（golfing），但前提是不能牺牲可读性。

### 命名规则

mathlib 在 Lean 4 中采用**统一的命名规范**，结合了下划线命名法（snake\_case）、驼峰命名法（CamelCase）等，用于不同类型的标识符：

* **文件命名：** 每个 `.lean` 源文件通常使用首字母大写的驼峰式命名（UpperCamelCase），例如 `LinearAlgebra/Basic.lean`。特殊情况下如果对象通常以小写字母命名（如表示 ℓ\_p 空间的 `lp.lean`），可在讨论后例外使用小写。

* \*\*声明命名：\*\**定理/引理名称*（证明对象，属于 `Prop` 的术语）一律采用下划线分隔的小写命名（snake\_case）。*定义和一般的值*（除命题外的其余`Type`类型项）采用小驼峰式（lowerCamelCase）。*类别、结构体、归纳类型、类型类等*（属于 `Prop` 或各级 `Type` 的大型定义，如数据类型）则使用大驼峰式（UpperCamelCase）。简单来说：**命题性质用下划线命名，类型和结构用大写驼峰，其他一般值和函数用小写驼峰**。例如，一个函数若返回某种结构体实例，其名称应当像该结构体名称一样采用驼峰式。又如，`MonoidHom.toOneHom_injective` 这个引理名称中，`MonoidHom` 和 `OneHom` 是大驼峰的类型名称，而整个引理名用下划线串联，遵循 snake\_case。

* **大小写与缩写：** 对于名称中的缩写，遵循“首字母大小写决定整体”原则，即如果缩写出现在名称开头则整体大写，否则整体小写。例如，表示小于等于的类命名为 `LE` 而不是 `Le`（因为出现在开头需要大写缩写），但在组合进其他名称（如 `le_refl`）时则使用小写形式。

* **命名避免歧义：** 如果引理名称涉及某个定义并处于不同的命名空间下，那么在引理命名中通常去掉命名空间前缀以简化名称。但若去掉后可能引起歧义，则可以在名称中加入部分命名空间以示区别（此时这些嵌入的名称仍遵循 CamelCase 转换）。同时，一个引理名称的各个“下划线分隔段”应当各自对应某个定义名或逻辑连接词，以增强可读性和一致性。

* **特定引理的命名模式：** mathlib 对某些常见类型的引理有约定俗成的命名后缀。例如，形如 `(∀ x, f x = g x) → f = g` 的引理应以 `.ext` 结尾，并标记 `@[ext]` 属性；形如 `f = g ↔ ∀ x, f x = g x` 的引理以 `.ext_iff` 结尾。单射（injectivity）相关的引理如果是双向的等价通常以 `_inj_iff` 结尾，单向的可用 `_inj`，同时尽量使用 `Function.Injective f` 形式书写引理结论并以 `_injective` 命名，等等。遵循这些惯例有助于他人快速了解引理作用，并利于自动工具识别。

### 文件组织结构

* **模块划分与文件位置：** mathlib 按照数学分支和主题对文件进行组织（如 `Algebra`、`Data`、`Topology` 等目录）。新的内容应尽量放入已有的、语义相关的文件或目录中。如果现有文件已涵盖相关主题，则将引理添加到那个文件；如无合适位置，再考虑新建文件，并放置在恰当的目录下。**切忌**为了使用某个辅助引理而在不相关的文件中加入过大的导入依赖——例如不应在基础代数文件中直接 `import Analysis` 范畴的内容。如果发现在某文件加入新内容需要引入很多额外的 `import`，这通常意味着新内容可能更适合放在别的文件，或者文件需要根据内容边界拆分重组。

* **避免导入过多模块：** 数学库有严格的模块依赖层次，贡献代码时应尽量维护这种良好的层次结构。新增的引理若需使用某个较高级别理论的结果，需谨慎评估其放置位置，不能贸然在底层模块中引入高层模块作为依赖。有经验的审稿人会检查 PR 中的 import 列表，防止不合理的依赖倒置，但作为贡献者，应提前自查 import 是否必要且合适。

* **文件长度与拆分：** 如果单个文件过长（例如超过约 1000 行）或者内容包含多个松散关联的主题，考虑按主题将文件拆分成更小的模块。这样既可以减少编译时间，又方便他人查找和阅读。一般来说，一个文件应专注于相对集中的主题。如果新增的内容使文件长度显著增加，维护者可能会建议将文件按自然的主题边界拆开。

* **更新入口文件：** 每当新建了一个文件后，需要运行 `lake exe mk_all`（Lean 4 下）来更新 `Mathlib.lean` 总入口文件，将新文件加入 mathlib 的编译索引。同时，在新文件开头正确设置模块名（对应文件路径）并添加所需的 import 列表，确保编译通过和依赖清晰。

### 注释与文档要求

* **文件头部注释：** 每个 mathlib 源文件都必须以文件头注释开头，其中包含版权声明、作者名单和对该文件内容的简要描述。版权和授权协议使用标准模板，作者栏列出对该文件有重要贡献的作者（可以多个，使用逗号分隔)。文件内容描述应概括本文件主要定义和定理的主题。文件头注释紧跟在模块名和 import 之前，并以 `/- ... -/`包裹。紧接其后列出该文件所需的所有 `import` 列表，每个 import 独占一行。

* **模块文档字符串：** 文件头注释和 import 之后，应紧接一个模块级文档字符串（module docstring），使用 `/-! ... -/` 包围，以 Markdown 格式编写。模块文档通常包括：**(1)** 文件的标题（以 `# ` 开头的一级标题），**(2)** 文件内容概述（主要定义、定理、所用技巧等），**(3)** 主要结果列表（如果不在概述中详细列出，可用二级标题“Main results”列出核心引理定理及作用），**(4)** 所定义的记号（如引入了新的符号则注明），**(5)** 实现的要点或注意事项（如重要的设计决策、用到的 type class 或 `simp` 正则形态等，通常用“Implementation notes”二级标题），**(6)** 参考文献（如有，引用书籍、论文或维基百科等来源，使用 BibTeX 键），以及 **(7)** 标签（tags，用于关键词搜索）。下面是一个模块文档字符串结构的示例：

  ```lean
  /-!
  # Foos and bars

  In this file we introduce `foo` and `bar`, two main concepts in ...  （← 文件内容简介）

  ## Main results
  - `exists_foo`: the main existence theorem of `foo`s.
  - `bar_of_foo_of_baz`: ... （← 主要结果列举）

  ## Notation
  - `|_|` : The barrification operator, see `bar_of_foo`.  （← 本文件定义的记号）

  ## References
  - *Title of reference* by Author, Year.  （← 参考文献）
  -/

  import Mathlib.Data.Foo  -- imports 列表
  ...
  ```

  编写模块文档时，注意使用 Markdown 标记来格式化内容，可包含公式和引用等。新的参考文献条目应添加到 `docs/references.bib` 文件中，并在文档中以 `[key]` 引用。

* **定义和定理的文档字符串：** mathlib **要求**每个重要的定义和主要定理都配有**文档字符串**（doc string）。文档字符串紧跟在定义/定理之前，使用 `"/--"` 开始、`"-/"` 结束。对于内容重要或可能被其他文件使用的引理，也鼓励添加文档说明。文档字符串应以简洁方式说明该定义或定理的数学意义。如果文档字符串是一个完整句子，则应以句号结尾；如果提及了知名定理的名称，应使用**粗体**突出显示。例如：

  ```lean
  /-- 如果 `q ≠ 0`，则定义 `q` 的 p-adic 范数为 `p ^ (-padicValRat p q)`；如果 `q = 0`，则 `q` 的 p-adic 范数定义为 0。 -/
  def padicNorm (p : ℕ) (q : ℚ) : ℚ := ...
  ```

  文档字符串可以在数学意义上适当“抽象”实现细节，即不必逐字描述代码实现，而侧重解释概念。mathlib 提供了自动检查机制，若某些定义或主要定理缺少文档字符串，CI 的文档检查(linter)会给出警告 (`docBlame` 和 `docBlameThm` 检查)。开发者可以在本地使用如 `#lint`、`#lint docBlame` 等命令来检查文档合规情况。

* **注释风格：** 除了文档字符串，代码中还会有一般注释。mathlib 规定使用不同的注释符号以区别用途：使用 `/-! ... -/` 作为**模块内章节的分隔注释**或大段说明（这些内容也会出现在自动生成的文档中）；使用 `/- ... -/` 作为一般的**块注释**，用于实现细节、临时标记 TODO 等，或者在证明中对一段代码进行注释说明；使用 `--` 开头的行为**行内简短注释**。当文档字符串或注释需要跨多行时，后续行不需要再额外缩进，以避免在 markdown 渲染时出现格式问题。

总结而言，在编写 mathlib 代码时，应保持风格一致：**命名语义清晰、代码格式规范、模块组织合理、注释和文档齐全**。mathlib 有一系列自动化的格式检查器和文档检查器，确保提交的代码符合上述要求，在 Pull Request 提交后这些检查会自动运行并反馈结果。

## 提交流程

贡献代码准备就绪后，需要通过 GitHub 提交 Pull Request (PR) 来将更改提议合并到 mathlib 主库。mathlib 社区对 Pull Request 的流程有明确的要求，包括前期沟通准备、PR 的创建提交、自动化测试、社区审查以及如何响应修改意见等。下面逐步介绍这些环节：

### 前期沟通与准备

在正式编写和提交代码之前，**强烈建议**先与社区进行沟通讨论。Lean 社区主要通过 [Zulip 聊天平台](https://leanprover.zulipchat.com)交流。您可以在 Zulip 的 **mathlib4** 或 **新人提问/贡献** 等板块介绍您计划贡献的内容和想法。社区成员通常会给予反馈，告诉您某结果是否已有现成实现、该贡献是否符合 mathlib 的整体方向，以及在技术上是否可行。提前讨论可以避免做重复工作，确保您的努力与社区需求相吻合。例如，有新贡献者想添加“向量空间”的相关定理，社区可能会指出 mathlib 已经有了更一般的 `Module` 模块可覆盖该内容。总之，在编写代码前先沟通，有助于理清思路、确认贡献的必要性，并可获得有用的指导。

技术准备方面，请确保您已安装 Lean 及 mathlib 开发环境，并熟悉 Git 基本操作。官方建议新贡献者可以阅读 mathlib4 的贡献者 Git 指南来了解如何使用 git 对 mathlib 进行版本控制。

### Fork 仓库与创建分支

mathlib 的源码托管在 GitHub 上 (仓库地址：`leanprover-community/mathlib4` 为 Lean4 版本，Lean3 对应 `mathlib`仓库)。您没有直接向官方仓库推送代码的权限，因此需要\*\*Fork（派生）\*\*仓库到您自己的 GitHub账户下。在 GitHub 上打开 mathlib4 仓库页面，点击右上角的 “Fork” 按钮即可在您的账户下建立一份 mathlib 副本。完成 Fork 后，将仓库克隆到本地：

```bash
git clone https://github.com/您的用户名/mathlib4.git
cd mathlib4
lake exe cache get    # 获取预编译的 olean 文件以加速编译（Lean4）
```

上述命令会将您 Fork 的仓库代码下载到本地，并通过 `lake exe cache get` 获取预编译的库文件，以便后续编译更快。

接下来，**创建一个新的分支**用于您的改动。mathlib 使用分支开发模型，**不要**直接在您 Fork 的 `master`（或 `main`）主分支上开发。在仓库目录下运行：

```bash
git switch -c my_new_branch
```

将创建并切换到名为 `my_new_branch` 的新分支（您也可以自行命名分支，例如根据功能命名）。在这个新分支上进行您代码的修改和新增内容。请保持这个分支专注于**单一主题**的改动，后续便于分开提交和审核。如果您计划进行多项相互独立的改进，建议为每个主题创建不同的分支分别提交 PR。

在开发过程中，您可以通过 `git commit -a` 等命令提交本地更改。提交前最好运行 `lake build` 编译一下，确保本地可以通过编译（如果修改范围很广，全编译可能较耗时，也可以等提交后让 CI 编译）。如果新增了文件，记得执行前述的 `lake exe mk_all` 来更新索引，并将更改一并提交。

### 提交 Pull Request

当您在新分支上的修改调试完毕、本地测试通过后，就可以将分支推送到您 Fork 的 GitHub 仓库，并发起 Pull Request (PR) 请求将更改合并到官方 mathlib。。具体流程如下：

1. **推送分支到 GitHub：** 使用 `git push` 将您的本地分支推送到您 GitHub 仓库上。如果是首次推送该分支，Git 会提示您设置上游分支，可按照提示的命令执行（如 `git push --set-upstream origin my_new_branch`）。

2. **在官方仓库创建 PR：** 登陆 GitHub，进入您 Fork 的 mathlib 仓库页面，您会看到刚推送的分支。点击 “Compare & Pull Request” 按钮（或到官方仓库选择 “New Pull Request”，再选取您的分支）。填写 PR 的标题和说明描述。PR 标题和描述应遵循 mathlib 的约定格式。通常标题以简洁的一句话概括更改，例如以 `feat:` 开头表示新增功能/定理，`fix:` 表示修复错误，`doc:` 用于文档修改等。可以在标题中用括号注明影响的模块或文件路径范围。描述部分应详细说明更改的动机、实现概述，如有与之前行为的不同行为也应解释。如果 PR 涉及**移动或删除**现有的定义，请在提交说明的最后（在 `---` 分隔线之前）列出`Moves:`和`Deletions:`列表，注明哪些标识符被移动到哪里或被删除，以便维护者更新索引。例如：

   ```
   Moves:
   * OldModule.OldName → NewModule.NewName

   Deletions:
   * ObsoleteLemma
   ```

   这样的说明有助于代码浏览和维护。**切记：** PR 描述越清晰全面，审阅者越容易理解您的更改背景，从而更快速地给出反馈。

3. **拆分 PR：** 如果您的改动很多，**尽量划分成多个小的 PR 分批提交**，而不是一个巨大的 PR。社区经验表明，PR **越小**则越容易被快速审核和合并。特别是对于新贡献者，小型 PR 可以更早获取反馈，避免在大量修改上花费时间却因方向问题被要求重大改动。您可以将一系列相关的引理分成几个逻辑单元分别提交，或者先提交基础部分，再逐步提交扩展。每个 PR 保持自包含且改动**专注单一主题**。对于大改动，您也可以在 Zulip 上提前告知，并将PR标记为“WIP”（work in progress，进行中）表示尚未完成，不需要立即审查。完成后再去掉 WIP 标签进入正式审查流程。

4. **通知社区：** mathlib 社区鼓励在提交 PR 后到 Zulip 的 `#new-PR` 或 `#PR reviews` 等讨论板块公告一下。例如发帖说明：“我提交了一个关于 XXX 的 PR，欢迎审查。”。这样有助于引起相关领域专家的注意，加快审查进程。

### 自动化测试（CI）要求

Pull Request 提交后，**持续集成** (Continuous Integration, CI) 系统会自动运行对 mathlib 的一系列测试和检查，以确保新改动不会破坏库的稳定性。CI 通常在几分钟到十几分钟内给出结果，您可以在 GitHub PR 页面看到检查状态：绿色对号表示所有测试通过，黄色圈表示测试尚在进行，红叉表示有测试未通过。

mathlib 的 CI 包括以下内容：

* **编译测试：** CI 会在一个干净环境下编译您的 PR 分支，确保**整个 mathlib 库**仍能成功编译且没有错误。这要求您的改动**不能**引入任何编译错误，亦不能留下未完成的证明（即代码中不能有 `sorry` 存在，否则 CI 将判定不通过）。mathlib 规定主分支中不允许出现未完成的证明（sorry），因此 PR 合并前必须完全解决所有证明目标。

* **Lint 风格检查：** mathlib 附带一组 *linters*（代码规范检查程序），CI 会运行这些 linters 来自动检查代码风格是否符合规范以及代码质量问题。例如，前文提到的文档字符串缺失检查 (`docBlame`)、不符合命名约定的标识符、没有用到的引入、存在的冗余定理等都会在 linter 阶段报告。CI 输出会列出具体的警告，如某行缺少空格、某定义缺文档等。常见的风格问题包括：缩进/换行格式错误、`by` 位置不当、`simp` 定理标签误用等等，很多都能通过 CI 提示修正。作为贡献者，您应查看CI报告，如有问题及时修复，然后推送更新。

* **自动化证明和测试：** mathlib 中有一些自动化的测试，确保关键定理没有回归或性能大幅下降等。这部分对一般数学定理贡献者影响不大，主要是针对元编程部分。但如果您的贡献涉及新的 Tactic，可能需要添加相应测试。

当 CI 报告红叉时，表示您的 PR 未通过测试。这时不要灰心，点击具体的失败检查可查看日志细节，根据提示修改代码后再次提交（push）即可重新触发 CI。**只有**当 CI **全部通过**（绿勾)后，维护者才会考虑合并您的 PR。在CI通过之前，您的PR通常会被标记为“awaiting-CI”状态，不进入正式审查序列。

### 社区审查流程与响应时间

mathlib 是社区维护项目，所有 Pull Request 都需要经过人工审查（review）后才能合并。每当您的 PR 通过CI后，就会进入**审查队列**等待社区志愿者或维护者的审核。审查流程及时间取决于PR的复杂度和社区维护者的忙闲程度：

* **审查队列与标签：** mathlib 使用 GitHub 的标签系统和 Zulip 的 **#queue** 机制管理 PR 审查进度。新提交且通过CI的 PR 通常会自动进入等待审查的队列。维护者会定期查看队列中的 PR 并分配审查。您的 PR 在 GitHub 页面会带有一些标签，如 `awaiting-review`（等待审查）等。对于新贡献者的小型PR，社区通常会较快给予关注。如果发现 PR 长时间无人回应，可以在 Zulip 上礼貌地询问或@相关领域的专家寻求审查。

* **审查者角色：** mathlib 社区有多层次的审查参与者，包括任何社区成员、具有 Reviewer 身份的志愿者，以及最终有权限合并的 Maintainers（维护者）。任何人都可以在您的 PR 下留言提出改进建议或发现问题。只有 Maintainers 能点击合并，但他们通常会等至少一位 Reviewer 点赞（approve）或充分讨论后再采取行动。Reviewer 和 Maintainer 可能会在您PR上添加特定标签来表示状态变化，例如标记 `awaiting-author` 表示需要作者响应，或者 `maintainer-merge` 表示已由审查员认可等待维护者最终检查。

* **审查反馈与修改：** 在审查过程中，审查者会通过评论对您的代码提出修改建议、疑问或指出错误。GitHub 在 PR 界面会将这些评论和代码对应行标注出来。一般而言，您应该**逐条回复或解决每一个审查意见**。这通常需要您根据建议修改代码并提交新的修订(commit)，然后在对应评论下点击 “Resolve conversation” 按钮表示该意见已被处理。例如，如果审查者指出命名不符合规范，您应重新命名相应标识符并修改所有引用，然后回复审查者确认已更正。对于审查者的每个问题，尽量给出反馈：要么通过代码更新解决，要么在评论中解释您这样处理的理由。如果您对审查意见有疑问，可以在评论中礼貌提问澄清。**切忌**无视某条评论，否则审查者可能认为您尚未处理，进而不会批准合并。

* **响应时间：** mathlib 的审查主要靠志愿者，因此等待几天乃至一两周都是正常的。一般来说，小的 PR（例如只增加一个简单引理或修改几行文档）可能在几天内就得到反馈并合并。而较大的 PR 则可能需要更长时间，数周不等。这段时间内，Maintainers 会尽量让队列流动起来，但也请贡献者耐心。如果感觉等待过久，可以在 Zulip 上友好地询问状态或者召集对口领域的人来 review。切记保持耐心和礼貌，mathlib 社区对新贡献者是友好的，只是审查资源有限。

* **“awaiting-author” 标签：** 当审查者提出修改意见后，通常会给 PR 加上“awaiting-author”（等待作者）的标签。这表示目前轮到您这个作者来更新 PR 了。在您没做出响应之前，Maintainers 不会进一步处理该 PR。您完成修改并提交后，需要**移除**这个标签以表示已经处理完审查者的意见，PR 可以重新进入待审队列。移除标签的方法是由有权限的协作者直接操作，或者您也可以在评论中留言指令 `-awaiting-author` 让机器人移除。一旦标签移除，审查者会看到您做出的更改，并开始新一轮审查流程。

* **特殊标签：** mathlib 还有其他一些标签辅助管理 PR。例如，`WIP` 表示工作尚在进行，不需审查；`blocked-by-other-PR` 表示此 PR 依赖于其他 PR 合并后才能继续；`easy` 表示这个 PR 改动非常小且无风险，可以快速审查通过。如果您的 PR 满足“非常简单”（如只添加了一个很基础的引理，改动行数很少，没有引入复杂逻辑）的条件，可以在评论中添加命令 `easy` 给自己标记。Easy PR 经常会被优先处理，以保持队列畅通。但请谨慎使用此标签，只有当您**确信**改动非常直白简单时再标记，否则不恰当地标记“easy”可能适得其反。

### 完成审查与合并

当审查者认为您的 PR 没有问题且符合各项要求时，会给予批准（approve）或 Maintainer 添加一个“ready-to-merge”标签。这时代表 PR 已通过最终审核。mathlib 使用一个名为 `bors` 的机器人来统一管理合并流程。维护者在 Zulip 或 GitHub 上下达 "bors merge" 命令后，bors 会将您的 PR 加入**合并队列**，按序自动合并到 master 主分支。bors 合并前也会再运行一次完整的 CI 测试，以确保合并操作与最新 master 分支没有冲突和全部通过。如果一切正常，您的代码将正式进入 mathlib 库。

有时维护者可能会使用 "bors d+"（delegate）下放合并权限给您，此时您的 PR 会被标记为“delegated”。含义是维护者认可合并但希望您再做最后检查或修改，然后由您自己触发 bors 合并（再次评论 "bors merge"）。一般只在改动非常小且维护者充分信任作者时才会这样做。

合并完成后，GitHub 会关闭您的 PR 并通知您。此时您可以删除自己仓库中对应的分支（选做）。社区通常也会在 Zulip 上对合并表示感谢。至此，您的贡献流程圆满结束！

## mathlib 社区对新定理、引理的接受标准

mathlib 作为一个大型数学库，对于收录新的定理或引理有一定的指导思想和标准。社区希望新增的数学内容既**正确通用**、又**不重复冗余**，并且符合库的发展方向。以下从几个方面说明社区对新定理/引理的期待：

### 通用性与不冗余性

mathlib 致力于构建尽可能**通用**的数学理论框架，避免收录过于特殊或重复的结果。这意味着：

* **尽可能一般化结果：** 如果一个引理或定理可以在更一般的上下文成立，mathlib 更倾向于收录**一般形式**而非具体特例。例如，与其在整数环上证明某性质，不如在更通用的环甚至群结构下证明，这样整数只是特例而无需单独一个定理。正因如此，很多看似缺失的定理其实在 mathlib 中以更一般的形式存在（新用户经常疑惑“mathlib 是否没有向量空间的概念？”，实际上以更一般的 `Module` 形式提供了相应功能）。当您贡献定理时，思考能否提升其一般性，比如放宽前提条件或适用范围，只要这样不会引入不必要的复杂性。

* **避免重复引理：** mathlib 库已相当庞大，新加入的结果很可能在某处已有。社区要求新贡献者务必先检查目标定理是否**已经存在**或可由现有定理直接推出。因为 mathlib **杜绝重复**的定理引入，除非确有需要（例如不同形式的引理在证明时各有用处）。如果提交的引理**实际上已被 mathlib 收录**（或只是名字和形式稍异），审查者会礼貌地指出已有的对应结果，并建议使用现有结果替代您的证明。例如，审查意见可能会说：“感谢你的证明，但我们已有一个通用的引理 `my_generic_lemma` 可以直接涵盖这个结论，请尝试改用它”。这是在提醒您的工作与已有内容冗余，需要修改后再提交。因此，在正式做证明前应尽量搜寻 mathlib 中相关内容，以避免重复劳动。

为达到上述要求，**如何检查某结论是否已在 mathlib 中存在**是每个贡献者需要掌握的技能。几个实用方法包括：

* *使用搜索工具：* Lean 提供了搜索已有定理的手段，例如 `#find` 命令可以通过模式匹配搜索符合给定类型签名的引理。此外，在 Lean 4 中，可以尝试使用 `apply?` 或 `exact?` tactic。例如，将你猜测 mathlib 已有的命题形如 `∀ x, P(x) → Q(x)` 写出来，然后在 proof 中输入 `exact?`，Lean 将尝试在库中找到匹配的lemma直接证明此目标。这种方法常常能发现隐藏在角落里的现成结果。

* *查看文档和索引：* mathlib 的文档网站提供了按主题分类的“理论概览”和“关键定理”列表。您可以在 [Mathlib 在线文档](https://leanprover-community.github.io/mathlib4_docs/) 上通过关键字搜索相关结果（也可使用“Loogle”搜索）。此外，一些社区维护的资源（如“一千个定理”列表）也列出了 mathlib 中的重要定理。利用这些资源查询您关注的定理是否已经存在非常有帮助。

* *请教社区：* 如果搜索仍无法确定某结果是否已在 mathlib，中英文皆可在 Zulip 或社区论坛上提问，描述您想添加的定理。mathlib 开发者对库内容往往非常熟悉，他们能迅速判断出是否已有相应结论或者类似结果。这也是为什么我们建议在动手前先沟通：可以直接问“库里是否已有关于 X 的定理？”以避免重复。

总之，**mathlib 欢迎新定理，但前提是该定理在库中确实缺失且具有独立价值**。提交前请确保已尽力核实不存在重复，并让定理保持最大可能的普适性。

### 数学严谨性和代码质量

mathlib 中的所有结果都是形式化证明的，**数学严谨性**在 Lean 中由内置的检查机制保证。换言之，只要您的 Lean 代码通过了编译和验证，就说明形式上它是严格正确的。然而，社区对于“严谨”的要求还体现在**证明风格和质量**上：

* **无空洞证明：** 如前所述，mathlib **不接受**包含未完成部分（`sorry`）的提交。每一条引理或定理都必须有完整自足的证明。即使是“显然成立”的结论，也需要给出证明步骤（或引用已有引理）。请务必在提交 PR 前将所有 `sorry` 补全，否则 CI 会直接拒绝。

* **清晰的证明结构：** 一个严谨的证明不仅要正确，还应当易于阅读和维护。这意味着证明尽量避免不必要的复杂化，使用恰当的 Lean tactic，必要时添加注释解释关键步骤。当证明较长或技巧性强时，建议在证明中以注释形式概述思路，或将证明拆解为几个小引理以提高清晰度。审稿人会关注您的证明是否有更简洁的写法，例如是否可以应用现有 tactics (`simp`, `linarith`, `ring` 等) 或引用已有结果来缩短证明。他们可能会给出优化建议甚至示范更优雅的证法。请虚心采纳这些改进意见，因为最终 mathlib 中合并的是经过优化和规范化的证明版本。

* **代码正确性与性能：** 除了逻辑正确，社区也希望代码性能良好（比如不会引入极端缓慢的证明导致编译时间暴增）。对于一般数学证明，这通常不是问题，但如果您定义了复杂的递归或使用大量计算，审查者可能会评估其性能影响并提出调整。确保没有明显的性能陷阱，如滥用高复杂度算法等。

* **风格一致性：** 您的代码风格需要与 mathlib 整体保持一致，如前文“风格与规范”部分所述。审查过程中，哪怕证明本身正确无误，若存在风格上的偏差（命名不符、格式混乱、缺少文档等），也会被要求修改后才能接受。这些修改有时可能繁琐，但它们保证了 mathlib 的统一性和可维护性，是十分必要的。幸运的是，CI 大部分情况下已经能自动捕获风格问题，您根据 CI 提示修正即可。

### 不适合加入的结果类型

尽管 mathlib 容纳各个数学领域的内容，但并非**任何**定理都适合放入 mathlib。社区在讨论是否接受某一新内容时，会考虑以下因素：

* **重复或易得的结果：** 正如前述，不接受与已有引理完全重复的结果。如果某结论可以用一两行 Lean 代码直接从已有库推导出（即属于“显然推论”），通常不会单独作为新引理收录，除非它在很多地方反复出现值得命名。换句话说，如果一个结果并不比直接调用现有引理组合证明更简洁，也许就不必新增它。审查者经常指出一些新手提交的引理其实只需 `library_search`（Lean 3 中的库搜索）或一行 `by simp` 即可证明，此类引理可能会被建议删去或者不予采纳。

* **过于具体的专有结果：** mathlib 倾向于包含通用的数学理论构件，而非针对某一特定问题的“孤立”定理。如果您的定理只对某个非常特定的情形有用，且缺乏更广泛的应用前景，维护者可能会质疑将其收入库的价值。例如，一个只在某道竞赛题背景下有意义的结论，若无法融入现有理论上下文，可能不适合纳入 mathlib（至少不会单独收录）。这种情况下，您可以考虑在更一般的理论框架下重新表述该结果，使其适用范围更广。

* **尚未完全发展的理论：** 有些领域mathlib暂未覆盖或刚起步，对于此类内容的贡献，社区会评估其**整体规划**。如果某贡献仅是某非常高级主题的一个定理，而该主题在 mathlib 中其他基础尚未建立，维护者可能建议先构建该领域的基础定义和框架，再加入定理，以保持库的层次完整性。直接添加一个“悬空”的结果往往不可取。当然，也有例外情况，比如这个结果本身就是基础定义的一部分或有独立价值。

* **违反数学公认原则的内容：** 绝大多数数学定理都可以接受，但如果有与数学主流观点明显冲突的内容（比如依赖不被多数人接受的公理），社区也会谨慎看待。不过 Lean 普遍采用经典逻辑和选择公理等，通常不会排斥常用数学原则。因此除非您在证明中引入了非常规公理（需要明确在声明中使用 `axiom` 或假设新的公理），否则一般不必担心这一点。

简单来说，mathlib 希望新增的定理**有助于丰富库的内容、被其他证明所用或在教学上有意义**，而不是随意收录“冷门小结果”。判断一个结果是否适合，很大程度上依赖于经验和共识。如果拿不准，可以在 Zulip 上提前询问社区意见。维护者有时也会对边界情况进行商讨，最终达成共识后再决定是否合并。

### 确认已有内容覆盖某定理的方法

作为贡献者，**确认某个定理是否已经被 mathlib 覆盖**是您的责任之一。这不仅避免重复劳动，也体现对社区时间的尊重。上文在“通用性与不冗余性”部分已提及一些方法，这里总结并补充几点实用技巧：

* **Lean 内置搜索：** 在 Lean 编辑器中，`#find` 和 `#check` 等命令可以帮助您探索已有定义。例如，如果您想找 `nat` 上关于加法的某种引理，可以尝试 `#find _ + _ = _ + _` 来搜索所有满足这种形态的定理。Lean4 中，使用 `exact?` tactic 也很方便：将待证目标放入 `exact?`，Lean 会尝试调用库中定理自动解决。如果成功，说明该定理已存在。另外，Lean4 提供的DOC搜索（如 Emacs/VSCode 中 Ctrl+Shift+P 调用“Lookup”或者使用社区维护的 `Loogle` 网页）也能通过关键词搜索相关定义。

* **阅读 mathlib 文档：** mathlib4 文档网站有每个模块的简介和索引，您可以通过目录浏览相关章节，看是否已有类似定理。特别地，**数学概览**页面列出了当前 mathlib 覆盖的主要数学领域。如果您的定理属于某一领域，先看看概览中相应章节，或许已经列出了相关结果和文件位置。

* **Zulip 历史讨论：** 有时候搜索引擎找不到，但可能在社区讨论中出现过。Lean 社区 Zulip 的公开历史存档是可检索的。尝试搜索关键词，看是否有他人在聊天中提过相关定理。如果曾有人问过或讨论过实现某定理，您可以参考他们的结论。

* **询问他人：** 最直接的方法还是在 Zulip 上提问。mathlib 开发者对库非常熟悉，一个简短的问题（哪怕用中文提问，很多人能看懂或用翻译工具）往往会很快得到“此结论可以用 X 引理证明”或“mathlib 中尚无此结果，你可以尝试贡献”的回复。社区乐于帮助您定位已有资源。

通过这些途径，您基本可以确信某个定理是否在 mathlib 中已有实现。如果确认没有重复，那么大胆地贡献吧！社区会欢迎新的补充。当然，如果您在 review 中还是被指出有重复，也不必气馁，毕竟 mathlib 内容极其丰富，有时难免遗漏。耐心按照建议修改即可。

---

总而言之，向 mathlib 贡献内容需要兼顾**代码规范**和**数学价值**两方面。请确保您的贡献遵循 mathlib 的技术风格要求，提交流程规范有序，并符合社区对内容的一致性和实用性的期望。提前与社区交流、仔细自查已有工作会大大提高您的贡献被接受的顺利程度。希望这份指南能帮助您了解贡献流程的全貌，祝您在 Lean 正式验证的旅程中取得成功，并期待您的成果被顺利合并进 mathlib，为社区做出一份贡献！

**参考来源：** LeanProver 官方社区指南和 mathlib 贡献文档等，上述内容均结合并引自这些权威资料，以确保准确性和时效性。如需更详细的信息，可查阅[Lean 社区贡献指南](https://leanprover-community.github.io/contribute/index.html)和 mathlib 文档，以及加入 Lean 社区获得实时帮助。祝愿您的 mathlib 贡献旅程愉快顺利！
